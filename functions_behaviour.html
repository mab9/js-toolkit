<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Functions, functions behaviour</title>
</head>
<body>
    <script>

        ////////////////////////////////////////////////////////////////////////////
        // Some Function facts
        //
        // - JS wird interpretiert und besitzt keinen Compiler
        // - Funktionen können überschrieben werden ohne Warnung
        // - Closure Funktion Funktionale Programmierung um den
        //   Namensraum eines Scopes nicht zu verschmutzen

        function fun1()    { return 1; }
        document.writeln( fun1()   === 1 );
        document.writeln( fun1(42) === 1 );

        // kein Kompilierungsfehler da JS kein Compiler verwendet
        document.writeln( fun1(42) === 0 === false );

        function fun2()    { return 1; }
        function fun2(arg) { return arg; }

        document.writeln( fun2() !== 1  );
        document.writeln( fun2() === undefined );
        document.writeln( fun2(42) === 42 );
        // Erkenntnis die Funktionen von JS können überschrieben werden, es erfolgt keine Fehlermeldung

        function noReturn()    { 1; }
        const noReturn2 = () => { 1; };
        const noReturn3 = () => 1;

        document.writeln( noReturn() !== 1 );
        document.writeln( noReturn() === undefined );
        document.writeln( noReturn2() !== 1 );
        document.writeln( noReturn3() === 1 );
        // Erkenntnis JS, das ohne geschweifte Klammer bezieht sich es auf einen Wert und mit auf einen Funktionsblock.

        // => zeigt auf die Funktion
        // { } einen Funktionsblock besteht aus Anweisungen, der Funktionsblock hat selbst keinen Wert und ist undefined
        // somit 1 !== { 1; } und 1 === 1


        // der Name einer Funktion referenziert die Funktion
        const myfun = fun1;
        const funs = [null, undefined, fun1, fun2];

        document.writeln( myfun() === 1 );
        document.writeln( funs[2]() === 1 );

        // Funktionale Programmierung

        // Closure gekapselte Funktion bla, die Idee ist den Namensraum (Scope) von JS nicht zu verschmutzen
        // die inner funktion kann auf den scope der äusseren funktion zugreifen (waszutunist(arg)). Von aussen ist die
        // innere Funktion nicht zu sehen.
        function doit(waszutunist) {
             return function bla(arg) { return waszutunist(arg) }
        }

        document.writeln( doit(fun1)(10) === 1 );
        document.writeln( doit(fun2)(10) === 10 );

        const doit2 = callme => (arg => callme(arg)) ;
        // oder const doit2 = callme => (arg => callme(arg)) ;

        document.writeln( doit2(fun1)(10) === 1 );

        const doFun2 = doit2(fun1);
        document.writeln( doFun2(10) === 1 );
        document.writeln( doFun2()   === 1 );


        // Zweites Closure Function Beispiel
        const plus = (x, y) => x+y;

        // plus(10)(6)
        /*
            const plus = x => y => x+y;

            function plus(x) {

                // closure function
                return function bla(y) {
                    return x + y;
                }
            }

         */
        document.writeln(plus(10)(6));
    </script>
</body>
</html>










